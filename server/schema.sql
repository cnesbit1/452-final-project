CREATE SCHEMA IF NOT EXISTS app;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_type
    WHERE typname = 'job_status'
    AND typnamespace = 'app'::regnamespace
  ) THEN
    CREATE TYPE app.job_status AS ENUM ('saved','applied','interview','offer','rejected','ghosted');
  END IF;
END$$;

CREATE TABLE IF NOT EXISTS app.users (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT now(),
  username TEXT NOT NULL UNIQUE,
  password_hash TEXT NOT NULL
);

-- Users are allowed to have multiple authtokens (different devices)
CREATE TABLE IF NOT EXISTS app.auths (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id BIGINT NOT NULL REFERENCES app.users(id) ON DELETE CASCADE,
  token VARCHAR(255) NOT NULL
);

CREATE TABLE IF NOT EXISTS app.company (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  company_name TEXT NOT NULL UNIQUE,
  total_applications BIGINT NOT NULL DEFAULT 0,
  number_ghosted BIGINT NOT NULL DEFAULT 0
);

CREATE TABLE IF NOT EXISTS app.jobs (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id BIGINT NOT NULL REFERENCES app.users(id) ON DELETE CASCADE,
  date_applied DATE,
  last_date_updated DATE DEFAULT CURRENT_DATE,
  company_name TEXT NOT NULL REFERENCES app.company(company_name) ON DELETE CASCADE,
  status app.job_status NOT NULL DEFAULT 'applied',
  position TEXT NOT NULL,
  posting_link TEXT,
  posting_description TEXT,
  resume_text TEXT,
  resume_s3_link TEXT,
  created_at TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX IF NOT EXISTS jobs_user_created_idx
  ON app.jobs(user_id, created_at DESC);

CREATE OR REPLACE VIEW app.user_stats AS
SELECT user_id,
       COUNT(*) AS total,
       COUNT(*) FILTER (WHERE status='rejected') AS rejected,
       COUNT(*) FILTER (WHERE status='ghosted') AS ghosted,
       COUNT(*) FILTER (WHERE status='interview') AS interviewing,
       COUNT(*) FILTER (WHERE status='offer') AS offers
FROM app.jobs
GROUP BY user_id;

CREATE OR REPLACE VIEW app.company_stats AS
SELECT user_id, company_name,
       COUNT(*) AS total_applications,
       COUNT(*) FILTER (WHERE status='ghosted') AS number_ghosted,
       MAX(date_applied) AS last_applied_at
FROM app.jobs
GROUP BY user_id, company_name;

CREATE INDEX IF NOT EXISTS jobs_user_status_created_idx ON app.jobs(user_id, status, created_at DESC);
CREATE INDEX IF NOT EXISTS jobs_user_company_created_idx ON app.jobs(user_id, company_name, created_at DESC);

----------TRIGGERS------------
CREATE OR REPLACE FUNCTION update_company_app_count()
RETURNS trigger AS $$
BEGIN
    -- When insert application, increment total_applications
    IF (TG_OP = 'INSERT') THEN
        UPDATE app.company
        SET total_applications = total_applications + 1
        WHERE company_name = NEW.company_name;
        RETURN NEW;

    -- When delete application, decrement total_applications
    ELSIF (TG_OP = 'DELETE') THEN
        UPDATE app.company
        SET total_applications = total_applications - 1
        WHERE company_name = OLD.company_name;
        RETURN OLD;
    END IF;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS jobs_applications_trigger ON app.jobs;
CREATE TRIGGER jobs_applications_trigger
AFTER INSERT OR DELETE ON app.jobs
FOR EACH ROW
EXECUTE FUNCTION update_company_app_count();


CREATE OR REPLACE FUNCTION update_company_ghost_count()
RETURNS trigger AS $$
BEGIN
    IF (TG_OP = 'DELETE' AND OLD.status = 'ghosted') THEN
        UPDATE app.company
        SET number_ghosted = number_ghosted - 1
        WHERE company_name = OLD.company_name;
        RETURN OLD;

    ELSIF (TG_OP = 'UPDATE') THEN
        IF (OLD.status != 'ghosted' AND NEW.status = 'ghosted') THEN
            UPDATE app.company
            SET number_ghosted = number_ghosted + 1
            WHERE company_name = NEW.company_name;
            RETURN NEW;
        ELSIF (OLD.status = 'ghosted' AND NEW.status != 'ghosted') THEN
            UPDATE app.company
            SET number_ghosted = number_ghosted - 1
            WHERE company_name = NEW.company_name;
            RETURN NEW;
        END IF;
        RETURN NEW;
    END IF;
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS jobs_ghost_trigger ON app.jobs;
CREATE TRIGGER jobs_ghost_trigger
AFTER UPDATE OR DELETE ON app.jobs
FOR EACH ROW
EXECUTE FUNCTION update_company_ghost_count();


-- create company if not exists when inserting job
CREATE OR REPLACE FUNCTION ensure_company_exists()
RETURNS trigger AS $$
BEGIN
    -- Check if a company with the name in the NEW job row already exists
    IF NOT EXISTS (
        SELECT 1 
        FROM app.company
        WHERE company_name = NEW.company_name
    ) THEN
        INSERT INTO app.company (company_name)
        VALUES (NEW.company_name);
    END IF;
    -- Return NEW to allow the original INSERT into the Job table to proceed.
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS jobs_ensure_company_exists_trigger ON app.jobs;
CREATE TRIGGER jobs_ensure_company_exists_trigger
BEFORE INSERT OR UPDATE ON app.jobs
FOR EACH ROW
EXECUTE FUNCTION ensure_company_exists();

---------- END TRIGGERS ------------------